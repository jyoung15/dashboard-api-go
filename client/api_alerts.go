/*
Meraki Dashboard API

A RESTful API to programmatically manage and monitor Cisco Meraki networks at scale.  > Date: 03 July, 2024 > > [Recent Updates](https://meraki.io/whats-new/)  ---  [API Documentation](https://meraki.io/api)  [Community Support](https://meraki.io/community)  [Meraki Homepage](https://www.meraki.com) 

API version: 1.48.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
	"reflect"
)


// AlertsAPIService AlertsAPI service
type AlertsAPIService service

type AlertsAPICreateNetworkSensorAlertsProfileRequest struct {
	ctx context.Context
	ApiService *AlertsAPIService
	networkId string
	createNetworkSensorAlertsProfileRequest *CreateNetworkSensorAlertsProfileRequest
}

func (r AlertsAPICreateNetworkSensorAlertsProfileRequest) CreateNetworkSensorAlertsProfileRequest(createNetworkSensorAlertsProfileRequest CreateNetworkSensorAlertsProfileRequest) AlertsAPICreateNetworkSensorAlertsProfileRequest {
	r.createNetworkSensorAlertsProfileRequest = &createNetworkSensorAlertsProfileRequest
	return r
}

func (r AlertsAPICreateNetworkSensorAlertsProfileRequest) Execute() (*GetNetworkSensorAlertsProfiles200ResponseInner, *http.Response, error) {
	return r.ApiService.CreateNetworkSensorAlertsProfileExecute(r)
}

/*
CreateNetworkSensorAlertsProfile Creates a sensor alert profile for a network.

Creates a sensor alert profile for a network.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param networkId Network ID
 @return AlertsAPICreateNetworkSensorAlertsProfileRequest
*/
func (a *AlertsAPIService) CreateNetworkSensorAlertsProfile(ctx context.Context, networkId string) AlertsAPICreateNetworkSensorAlertsProfileRequest {
	return AlertsAPICreateNetworkSensorAlertsProfileRequest{
		ApiService: a,
		ctx: ctx,
		networkId: networkId,
	}
}

// Execute executes the request
//  @return GetNetworkSensorAlertsProfiles200ResponseInner
func (a *AlertsAPIService) CreateNetworkSensorAlertsProfileExecute(r AlertsAPICreateNetworkSensorAlertsProfileRequest) (*GetNetworkSensorAlertsProfiles200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetNetworkSensorAlertsProfiles200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertsAPIService.CreateNetworkSensorAlertsProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networks/{networkId}/sensor/alerts/profiles"
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", url.PathEscape(parameterValueToString(r.networkId, "networkId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createNetworkSensorAlertsProfileRequest == nil {
		return localVarReturnValue, nil, reportError("createNetworkSensorAlertsProfileRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createNetworkSensorAlertsProfileRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AlertsAPICreateOrganizationAlertsProfileRequest struct {
	ctx context.Context
	ApiService *AlertsAPIService
	organizationId string
	createOrganizationAlertsProfileRequest *CreateOrganizationAlertsProfileRequest
}

func (r AlertsAPICreateOrganizationAlertsProfileRequest) CreateOrganizationAlertsProfileRequest(createOrganizationAlertsProfileRequest CreateOrganizationAlertsProfileRequest) AlertsAPICreateOrganizationAlertsProfileRequest {
	r.createOrganizationAlertsProfileRequest = &createOrganizationAlertsProfileRequest
	return r
}

func (r AlertsAPICreateOrganizationAlertsProfileRequest) Execute() (*GetOrganizationAlertsProfiles200ResponseInner, *http.Response, error) {
	return r.ApiService.CreateOrganizationAlertsProfileExecute(r)
}

/*
CreateOrganizationAlertsProfile Create an organization-wide alert configuration

Create an organization-wide alert configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @return AlertsAPICreateOrganizationAlertsProfileRequest
*/
func (a *AlertsAPIService) CreateOrganizationAlertsProfile(ctx context.Context, organizationId string) AlertsAPICreateOrganizationAlertsProfileRequest {
	return AlertsAPICreateOrganizationAlertsProfileRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
//  @return GetOrganizationAlertsProfiles200ResponseInner
func (a *AlertsAPIService) CreateOrganizationAlertsProfileExecute(r AlertsAPICreateOrganizationAlertsProfileRequest) (*GetOrganizationAlertsProfiles200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetOrganizationAlertsProfiles200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertsAPIService.CreateOrganizationAlertsProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/alerts/profiles"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterValueToString(r.organizationId, "organizationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createOrganizationAlertsProfileRequest == nil {
		return localVarReturnValue, nil, reportError("createOrganizationAlertsProfileRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createOrganizationAlertsProfileRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AlertsAPIDeleteNetworkSensorAlertsProfileRequest struct {
	ctx context.Context
	ApiService *AlertsAPIService
	networkId string
	id string
}

func (r AlertsAPIDeleteNetworkSensorAlertsProfileRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteNetworkSensorAlertsProfileExecute(r)
}

/*
DeleteNetworkSensorAlertsProfile Deletes a sensor alert profile from a network.

Deletes a sensor alert profile from a network.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param networkId Network ID
 @param id ID
 @return AlertsAPIDeleteNetworkSensorAlertsProfileRequest
*/
func (a *AlertsAPIService) DeleteNetworkSensorAlertsProfile(ctx context.Context, networkId string, id string) AlertsAPIDeleteNetworkSensorAlertsProfileRequest {
	return AlertsAPIDeleteNetworkSensorAlertsProfileRequest{
		ApiService: a,
		ctx: ctx,
		networkId: networkId,
		id: id,
	}
}

// Execute executes the request
func (a *AlertsAPIService) DeleteNetworkSensorAlertsProfileExecute(r AlertsAPIDeleteNetworkSensorAlertsProfileRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertsAPIService.DeleteNetworkSensorAlertsProfile")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networks/{networkId}/sensor/alerts/profiles/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", url.PathEscape(parameterValueToString(r.networkId, "networkId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AlertsAPIDeleteOrganizationAlertsProfileRequest struct {
	ctx context.Context
	ApiService *AlertsAPIService
	organizationId string
	alertConfigId string
}

func (r AlertsAPIDeleteOrganizationAlertsProfileRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteOrganizationAlertsProfileExecute(r)
}

/*
DeleteOrganizationAlertsProfile Removes an organization-wide alert config

Removes an organization-wide alert config

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @param alertConfigId Alert config ID
 @return AlertsAPIDeleteOrganizationAlertsProfileRequest
*/
func (a *AlertsAPIService) DeleteOrganizationAlertsProfile(ctx context.Context, organizationId string, alertConfigId string) AlertsAPIDeleteOrganizationAlertsProfileRequest {
	return AlertsAPIDeleteOrganizationAlertsProfileRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
		alertConfigId: alertConfigId,
	}
}

// Execute executes the request
func (a *AlertsAPIService) DeleteOrganizationAlertsProfileExecute(r AlertsAPIDeleteOrganizationAlertsProfileRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertsAPIService.DeleteOrganizationAlertsProfile")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/alerts/profiles/{alertConfigId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterValueToString(r.organizationId, "organizationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"alertConfigId"+"}", url.PathEscape(parameterValueToString(r.alertConfigId, "alertConfigId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AlertsAPIDismissOrganizationAssuranceAlertsRequest struct {
	ctx context.Context
	ApiService *AlertsAPIService
	organizationId string
	dismissOrganizationAssuranceAlertsRequest *DismissOrganizationAssuranceAlertsRequest
}

func (r AlertsAPIDismissOrganizationAssuranceAlertsRequest) DismissOrganizationAssuranceAlertsRequest(dismissOrganizationAssuranceAlertsRequest DismissOrganizationAssuranceAlertsRequest) AlertsAPIDismissOrganizationAssuranceAlertsRequest {
	r.dismissOrganizationAssuranceAlertsRequest = &dismissOrganizationAssuranceAlertsRequest
	return r
}

func (r AlertsAPIDismissOrganizationAssuranceAlertsRequest) Execute() (*http.Response, error) {
	return r.ApiService.DismissOrganizationAssuranceAlertsExecute(r)
}

/*
DismissOrganizationAssuranceAlerts Dismiss health alerts

Dismiss health alerts

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @return AlertsAPIDismissOrganizationAssuranceAlertsRequest
*/
func (a *AlertsAPIService) DismissOrganizationAssuranceAlerts(ctx context.Context, organizationId string) AlertsAPIDismissOrganizationAssuranceAlertsRequest {
	return AlertsAPIDismissOrganizationAssuranceAlertsRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
func (a *AlertsAPIService) DismissOrganizationAssuranceAlertsExecute(r AlertsAPIDismissOrganizationAssuranceAlertsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertsAPIService.DismissOrganizationAssuranceAlerts")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/assurance/alerts/dismiss"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterValueToString(r.organizationId, "organizationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dismissOrganizationAssuranceAlertsRequest == nil {
		return nil, reportError("dismissOrganizationAssuranceAlertsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dismissOrganizationAssuranceAlertsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AlertsAPIGetNetworkAlertsHistoryRequest struct {
	ctx context.Context
	ApiService *AlertsAPIService
	networkId string
	perPage *int32
	startingAfter *string
	endingBefore *string
}

// The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100.
func (r AlertsAPIGetNetworkAlertsHistoryRequest) PerPage(perPage int32) AlertsAPIGetNetworkAlertsHistoryRequest {
	r.perPage = &perPage
	return r
}

// A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
func (r AlertsAPIGetNetworkAlertsHistoryRequest) StartingAfter(startingAfter string) AlertsAPIGetNetworkAlertsHistoryRequest {
	r.startingAfter = &startingAfter
	return r
}

// A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
func (r AlertsAPIGetNetworkAlertsHistoryRequest) EndingBefore(endingBefore string) AlertsAPIGetNetworkAlertsHistoryRequest {
	r.endingBefore = &endingBefore
	return r
}

func (r AlertsAPIGetNetworkAlertsHistoryRequest) Execute() ([]GetNetworkAlertsHistory200ResponseInner, *http.Response, error) {
	return r.ApiService.GetNetworkAlertsHistoryExecute(r)
}

/*
GetNetworkAlertsHistory Return the alert history for this network

Return the alert history for this network

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param networkId Network ID
 @return AlertsAPIGetNetworkAlertsHistoryRequest
*/
func (a *AlertsAPIService) GetNetworkAlertsHistory(ctx context.Context, networkId string) AlertsAPIGetNetworkAlertsHistoryRequest {
	return AlertsAPIGetNetworkAlertsHistoryRequest{
		ApiService: a,
		ctx: ctx,
		networkId: networkId,
	}
}

// Execute executes the request
//  @return []GetNetworkAlertsHistory200ResponseInner
func (a *AlertsAPIService) GetNetworkAlertsHistoryExecute(r AlertsAPIGetNetworkAlertsHistoryRequest) ([]GetNetworkAlertsHistory200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetNetworkAlertsHistory200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertsAPIService.GetNetworkAlertsHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networks/{networkId}/alerts/history"
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", url.PathEscape(parameterValueToString(r.networkId, "networkId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "perPage", r.perPage, "")
	}
	if r.startingAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startingAfter", r.startingAfter, "")
	}
	if r.endingBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endingBefore", r.endingBefore, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AlertsAPIGetNetworkAlertsSettingsRequest struct {
	ctx context.Context
	ApiService *AlertsAPIService
	networkId string
}

func (r AlertsAPIGetNetworkAlertsSettingsRequest) Execute() (*GetNetworkAlertsSettings200Response, *http.Response, error) {
	return r.ApiService.GetNetworkAlertsSettingsExecute(r)
}

/*
GetNetworkAlertsSettings Return the alert configuration for this network

Return the alert configuration for this network

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param networkId Network ID
 @return AlertsAPIGetNetworkAlertsSettingsRequest
*/
func (a *AlertsAPIService) GetNetworkAlertsSettings(ctx context.Context, networkId string) AlertsAPIGetNetworkAlertsSettingsRequest {
	return AlertsAPIGetNetworkAlertsSettingsRequest{
		ApiService: a,
		ctx: ctx,
		networkId: networkId,
	}
}

// Execute executes the request
//  @return GetNetworkAlertsSettings200Response
func (a *AlertsAPIService) GetNetworkAlertsSettingsExecute(r AlertsAPIGetNetworkAlertsSettingsRequest) (*GetNetworkAlertsSettings200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetNetworkAlertsSettings200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertsAPIService.GetNetworkAlertsSettings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networks/{networkId}/alerts/settings"
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", url.PathEscape(parameterValueToString(r.networkId, "networkId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AlertsAPIGetNetworkHealthAlertsRequest struct {
	ctx context.Context
	ApiService *AlertsAPIService
	networkId string
}

func (r AlertsAPIGetNetworkHealthAlertsRequest) Execute() ([]GetNetworkHealthAlerts200ResponseInner, *http.Response, error) {
	return r.ApiService.GetNetworkHealthAlertsExecute(r)
}

/*
GetNetworkHealthAlerts Return all global alerts on this network

Return all global alerts on this network

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param networkId Network ID
 @return AlertsAPIGetNetworkHealthAlertsRequest

Deprecated
*/
func (a *AlertsAPIService) GetNetworkHealthAlerts(ctx context.Context, networkId string) AlertsAPIGetNetworkHealthAlertsRequest {
	return AlertsAPIGetNetworkHealthAlertsRequest{
		ApiService: a,
		ctx: ctx,
		networkId: networkId,
	}
}

// Execute executes the request
//  @return []GetNetworkHealthAlerts200ResponseInner
// Deprecated
func (a *AlertsAPIService) GetNetworkHealthAlertsExecute(r AlertsAPIGetNetworkHealthAlertsRequest) ([]GetNetworkHealthAlerts200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetNetworkHealthAlerts200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertsAPIService.GetNetworkHealthAlerts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networks/{networkId}/health/alerts"
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", url.PathEscape(parameterValueToString(r.networkId, "networkId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AlertsAPIGetNetworkSensorAlertsCurrentOverviewByMetricRequest struct {
	ctx context.Context
	ApiService *AlertsAPIService
	networkId string
}

func (r AlertsAPIGetNetworkSensorAlertsCurrentOverviewByMetricRequest) Execute() (*GetNetworkSensorAlertsCurrentOverviewByMetric200Response, *http.Response, error) {
	return r.ApiService.GetNetworkSensorAlertsCurrentOverviewByMetricExecute(r)
}

/*
GetNetworkSensorAlertsCurrentOverviewByMetric Return an overview of currently alerting sensors by metric

Return an overview of currently alerting sensors by metric

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param networkId Network ID
 @return AlertsAPIGetNetworkSensorAlertsCurrentOverviewByMetricRequest
*/
func (a *AlertsAPIService) GetNetworkSensorAlertsCurrentOverviewByMetric(ctx context.Context, networkId string) AlertsAPIGetNetworkSensorAlertsCurrentOverviewByMetricRequest {
	return AlertsAPIGetNetworkSensorAlertsCurrentOverviewByMetricRequest{
		ApiService: a,
		ctx: ctx,
		networkId: networkId,
	}
}

// Execute executes the request
//  @return GetNetworkSensorAlertsCurrentOverviewByMetric200Response
func (a *AlertsAPIService) GetNetworkSensorAlertsCurrentOverviewByMetricExecute(r AlertsAPIGetNetworkSensorAlertsCurrentOverviewByMetricRequest) (*GetNetworkSensorAlertsCurrentOverviewByMetric200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetNetworkSensorAlertsCurrentOverviewByMetric200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertsAPIService.GetNetworkSensorAlertsCurrentOverviewByMetric")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networks/{networkId}/sensor/alerts/current/overview/byMetric"
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", url.PathEscape(parameterValueToString(r.networkId, "networkId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AlertsAPIGetNetworkSensorAlertsOverviewByMetricRequest struct {
	ctx context.Context
	ApiService *AlertsAPIService
	networkId string
	t0 *string
	t1 *string
	timespan *float32
	interval *int32
}

// The beginning of the timespan for the data. The maximum lookback period is 365 days from today.
func (r AlertsAPIGetNetworkSensorAlertsOverviewByMetricRequest) T0(t0 string) AlertsAPIGetNetworkSensorAlertsOverviewByMetricRequest {
	r.t0 = &t0
	return r
}

// The end of the timespan for the data. t1 can be a maximum of 31 days after t0.
func (r AlertsAPIGetNetworkSensorAlertsOverviewByMetricRequest) T1(t1 string) AlertsAPIGetNetworkSensorAlertsOverviewByMetricRequest {
	r.t1 = &t1
	return r
}

// The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days.
func (r AlertsAPIGetNetworkSensorAlertsOverviewByMetricRequest) Timespan(timespan float32) AlertsAPIGetNetworkSensorAlertsOverviewByMetricRequest {
	r.timespan = &timespan
	return r
}

// The time interval in seconds for returned data. The valid intervals are: 86400, 604800. The default is 604800.
func (r AlertsAPIGetNetworkSensorAlertsOverviewByMetricRequest) Interval(interval int32) AlertsAPIGetNetworkSensorAlertsOverviewByMetricRequest {
	r.interval = &interval
	return r
}

func (r AlertsAPIGetNetworkSensorAlertsOverviewByMetricRequest) Execute() ([]GetNetworkSensorAlertsOverviewByMetric200ResponseInner, *http.Response, error) {
	return r.ApiService.GetNetworkSensorAlertsOverviewByMetricExecute(r)
}

/*
GetNetworkSensorAlertsOverviewByMetric Return an overview of alert occurrences over a timespan, by metric

Return an overview of alert occurrences over a timespan, by metric

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param networkId Network ID
 @return AlertsAPIGetNetworkSensorAlertsOverviewByMetricRequest
*/
func (a *AlertsAPIService) GetNetworkSensorAlertsOverviewByMetric(ctx context.Context, networkId string) AlertsAPIGetNetworkSensorAlertsOverviewByMetricRequest {
	return AlertsAPIGetNetworkSensorAlertsOverviewByMetricRequest{
		ApiService: a,
		ctx: ctx,
		networkId: networkId,
	}
}

// Execute executes the request
//  @return []GetNetworkSensorAlertsOverviewByMetric200ResponseInner
func (a *AlertsAPIService) GetNetworkSensorAlertsOverviewByMetricExecute(r AlertsAPIGetNetworkSensorAlertsOverviewByMetricRequest) ([]GetNetworkSensorAlertsOverviewByMetric200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetNetworkSensorAlertsOverviewByMetric200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertsAPIService.GetNetworkSensorAlertsOverviewByMetric")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networks/{networkId}/sensor/alerts/overview/byMetric"
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", url.PathEscape(parameterValueToString(r.networkId, "networkId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.t0 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "t0", r.t0, "")
	}
	if r.t1 != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "t1", r.t1, "")
	}
	if r.timespan != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timespan", r.timespan, "")
	}
	if r.interval != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "interval", r.interval, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AlertsAPIGetNetworkSensorAlertsProfileRequest struct {
	ctx context.Context
	ApiService *AlertsAPIService
	networkId string
	id string
}

func (r AlertsAPIGetNetworkSensorAlertsProfileRequest) Execute() (*GetNetworkSensorAlertsProfiles200ResponseInner, *http.Response, error) {
	return r.ApiService.GetNetworkSensorAlertsProfileExecute(r)
}

/*
GetNetworkSensorAlertsProfile Show details of a sensor alert profile for a network.

Show details of a sensor alert profile for a network.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param networkId Network ID
 @param id ID
 @return AlertsAPIGetNetworkSensorAlertsProfileRequest
*/
func (a *AlertsAPIService) GetNetworkSensorAlertsProfile(ctx context.Context, networkId string, id string) AlertsAPIGetNetworkSensorAlertsProfileRequest {
	return AlertsAPIGetNetworkSensorAlertsProfileRequest{
		ApiService: a,
		ctx: ctx,
		networkId: networkId,
		id: id,
	}
}

// Execute executes the request
//  @return GetNetworkSensorAlertsProfiles200ResponseInner
func (a *AlertsAPIService) GetNetworkSensorAlertsProfileExecute(r AlertsAPIGetNetworkSensorAlertsProfileRequest) (*GetNetworkSensorAlertsProfiles200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetNetworkSensorAlertsProfiles200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertsAPIService.GetNetworkSensorAlertsProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networks/{networkId}/sensor/alerts/profiles/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", url.PathEscape(parameterValueToString(r.networkId, "networkId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AlertsAPIGetNetworkSensorAlertsProfilesRequest struct {
	ctx context.Context
	ApiService *AlertsAPIService
	networkId string
}

func (r AlertsAPIGetNetworkSensorAlertsProfilesRequest) Execute() ([]GetNetworkSensorAlertsProfiles200ResponseInner, *http.Response, error) {
	return r.ApiService.GetNetworkSensorAlertsProfilesExecute(r)
}

/*
GetNetworkSensorAlertsProfiles Lists all sensor alert profiles for a network.

Lists all sensor alert profiles for a network.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param networkId Network ID
 @return AlertsAPIGetNetworkSensorAlertsProfilesRequest
*/
func (a *AlertsAPIService) GetNetworkSensorAlertsProfiles(ctx context.Context, networkId string) AlertsAPIGetNetworkSensorAlertsProfilesRequest {
	return AlertsAPIGetNetworkSensorAlertsProfilesRequest{
		ApiService: a,
		ctx: ctx,
		networkId: networkId,
	}
}

// Execute executes the request
//  @return []GetNetworkSensorAlertsProfiles200ResponseInner
func (a *AlertsAPIService) GetNetworkSensorAlertsProfilesExecute(r AlertsAPIGetNetworkSensorAlertsProfilesRequest) ([]GetNetworkSensorAlertsProfiles200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetNetworkSensorAlertsProfiles200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertsAPIService.GetNetworkSensorAlertsProfiles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networks/{networkId}/sensor/alerts/profiles"
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", url.PathEscape(parameterValueToString(r.networkId, "networkId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AlertsAPIGetOrganizationAlertsProfilesRequest struct {
	ctx context.Context
	ApiService *AlertsAPIService
	organizationId string
}

func (r AlertsAPIGetOrganizationAlertsProfilesRequest) Execute() ([]GetOrganizationAlertsProfiles200ResponseInner, *http.Response, error) {
	return r.ApiService.GetOrganizationAlertsProfilesExecute(r)
}

/*
GetOrganizationAlertsProfiles List all organization-wide alert configurations

List all organization-wide alert configurations

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @return AlertsAPIGetOrganizationAlertsProfilesRequest
*/
func (a *AlertsAPIService) GetOrganizationAlertsProfiles(ctx context.Context, organizationId string) AlertsAPIGetOrganizationAlertsProfilesRequest {
	return AlertsAPIGetOrganizationAlertsProfilesRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
//  @return []GetOrganizationAlertsProfiles200ResponseInner
func (a *AlertsAPIService) GetOrganizationAlertsProfilesExecute(r AlertsAPIGetOrganizationAlertsProfilesRequest) ([]GetOrganizationAlertsProfiles200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetOrganizationAlertsProfiles200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertsAPIService.GetOrganizationAlertsProfiles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/alerts/profiles"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterValueToString(r.organizationId, "organizationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AlertsAPIGetOrganizationAssuranceAlertRequest struct {
	ctx context.Context
	ApiService *AlertsAPIService
	organizationId string
	id string
}

func (r AlertsAPIGetOrganizationAssuranceAlertRequest) Execute() (*GetOrganizationAssuranceAlert200Response, *http.Response, error) {
	return r.ApiService.GetOrganizationAssuranceAlertExecute(r)
}

/*
GetOrganizationAssuranceAlert Return a singular Health Alert by its id

Return a singular Health Alert by its id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @param id ID
 @return AlertsAPIGetOrganizationAssuranceAlertRequest
*/
func (a *AlertsAPIService) GetOrganizationAssuranceAlert(ctx context.Context, organizationId string, id string) AlertsAPIGetOrganizationAssuranceAlertRequest {
	return AlertsAPIGetOrganizationAssuranceAlertRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
		id: id,
	}
}

// Execute executes the request
//  @return GetOrganizationAssuranceAlert200Response
func (a *AlertsAPIService) GetOrganizationAssuranceAlertExecute(r AlertsAPIGetOrganizationAssuranceAlertRequest) (*GetOrganizationAssuranceAlert200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetOrganizationAssuranceAlert200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertsAPIService.GetOrganizationAssuranceAlert")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/assurance/alerts/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterValueToString(r.organizationId, "organizationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AlertsAPIGetOrganizationAssuranceAlertsRequest struct {
	ctx context.Context
	ApiService *AlertsAPIService
	organizationId string
	perPage *int32
	startingAfter *string
	endingBefore *string
	sortOrder *string
	networkId *string
	severity *string
	types *[]string
	tsStart *time.Time
	tsEnd *time.Time
	category *string
	sortBy *string
	serials *[]string
	deviceTypes *[]string
	deviceTags *[]string
	active *bool
	dismissed *bool
	resolved *bool
	suppressAlertsForOfflineNodes *bool
}

// The number of entries per page returned. Acceptable range is 4 - 300. Default is 30.
func (r AlertsAPIGetOrganizationAssuranceAlertsRequest) PerPage(perPage int32) AlertsAPIGetOrganizationAssuranceAlertsRequest {
	r.perPage = &perPage
	return r
}

// A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
func (r AlertsAPIGetOrganizationAssuranceAlertsRequest) StartingAfter(startingAfter string) AlertsAPIGetOrganizationAssuranceAlertsRequest {
	r.startingAfter = &startingAfter
	return r
}

// A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
func (r AlertsAPIGetOrganizationAssuranceAlertsRequest) EndingBefore(endingBefore string) AlertsAPIGetOrganizationAssuranceAlertsRequest {
	r.endingBefore = &endingBefore
	return r
}

// Sorted order of entries. Order options are &#39;ascending&#39; and &#39;descending&#39;. Default is &#39;ascending&#39;.
func (r AlertsAPIGetOrganizationAssuranceAlertsRequest) SortOrder(sortOrder string) AlertsAPIGetOrganizationAssuranceAlertsRequest {
	r.sortOrder = &sortOrder
	return r
}

// Optional parameter to filter alerts by network ids.
func (r AlertsAPIGetOrganizationAssuranceAlertsRequest) NetworkId(networkId string) AlertsAPIGetOrganizationAssuranceAlertsRequest {
	r.networkId = &networkId
	return r
}

// Optional parameter to filter by severity type.
func (r AlertsAPIGetOrganizationAssuranceAlertsRequest) Severity(severity string) AlertsAPIGetOrganizationAssuranceAlertsRequest {
	r.severity = &severity
	return r
}

// Optional parameter to filter by alert type.
func (r AlertsAPIGetOrganizationAssuranceAlertsRequest) Types(types []string) AlertsAPIGetOrganizationAssuranceAlertsRequest {
	r.types = &types
	return r
}

// Optional parameter to filter by starting timestamp
func (r AlertsAPIGetOrganizationAssuranceAlertsRequest) TsStart(tsStart time.Time) AlertsAPIGetOrganizationAssuranceAlertsRequest {
	r.tsStart = &tsStart
	return r
}

// Optional parameter to filter by end timestamp
func (r AlertsAPIGetOrganizationAssuranceAlertsRequest) TsEnd(tsEnd time.Time) AlertsAPIGetOrganizationAssuranceAlertsRequest {
	r.tsEnd = &tsEnd
	return r
}

// Optional parameter to filter by category.
func (r AlertsAPIGetOrganizationAssuranceAlertsRequest) Category(category string) AlertsAPIGetOrganizationAssuranceAlertsRequest {
	r.category = &category
	return r
}

// Optional parameter to set column to sort by.
func (r AlertsAPIGetOrganizationAssuranceAlertsRequest) SortBy(sortBy string) AlertsAPIGetOrganizationAssuranceAlertsRequest {
	r.sortBy = &sortBy
	return r
}

// Optional parameter to filter by primary device serial
func (r AlertsAPIGetOrganizationAssuranceAlertsRequest) Serials(serials []string) AlertsAPIGetOrganizationAssuranceAlertsRequest {
	r.serials = &serials
	return r
}

// Optional parameter to filter by device types
func (r AlertsAPIGetOrganizationAssuranceAlertsRequest) DeviceTypes(deviceTypes []string) AlertsAPIGetOrganizationAssuranceAlertsRequest {
	r.deviceTypes = &deviceTypes
	return r
}

// Optional parameter to filter by device tags
func (r AlertsAPIGetOrganizationAssuranceAlertsRequest) DeviceTags(deviceTags []string) AlertsAPIGetOrganizationAssuranceAlertsRequest {
	r.deviceTags = &deviceTags
	return r
}

// Optional parameter to filter by active alerts defaults to true
func (r AlertsAPIGetOrganizationAssuranceAlertsRequest) Active(active bool) AlertsAPIGetOrganizationAssuranceAlertsRequest {
	r.active = &active
	return r
}

// Optional parameter to filter by dismissed alerts defaults to false
func (r AlertsAPIGetOrganizationAssuranceAlertsRequest) Dismissed(dismissed bool) AlertsAPIGetOrganizationAssuranceAlertsRequest {
	r.dismissed = &dismissed
	return r
}

// Optional parameter to filter by resolved alerts defaults to false
func (r AlertsAPIGetOrganizationAssuranceAlertsRequest) Resolved(resolved bool) AlertsAPIGetOrganizationAssuranceAlertsRequest {
	r.resolved = &resolved
	return r
}

// When set to true the api will only return connectivity alerts for a given device if that device is in an offline state. This only applies to devices. This is ignored when resolved is true. Example:  If a Switch has a VLan Mismatch and is Unreachable. only the Unreachable alert will be returned. Defaults to false.
func (r AlertsAPIGetOrganizationAssuranceAlertsRequest) SuppressAlertsForOfflineNodes(suppressAlertsForOfflineNodes bool) AlertsAPIGetOrganizationAssuranceAlertsRequest {
	r.suppressAlertsForOfflineNodes = &suppressAlertsForOfflineNodes
	return r
}

func (r AlertsAPIGetOrganizationAssuranceAlertsRequest) Execute() ([]GetOrganizationAssuranceAlerts200ResponseInner, *http.Response, error) {
	return r.ApiService.GetOrganizationAssuranceAlertsExecute(r)
}

/*
GetOrganizationAssuranceAlerts Return all health alerts for an organization

Return all health alerts for an organization

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @return AlertsAPIGetOrganizationAssuranceAlertsRequest
*/
func (a *AlertsAPIService) GetOrganizationAssuranceAlerts(ctx context.Context, organizationId string) AlertsAPIGetOrganizationAssuranceAlertsRequest {
	return AlertsAPIGetOrganizationAssuranceAlertsRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
//  @return []GetOrganizationAssuranceAlerts200ResponseInner
func (a *AlertsAPIService) GetOrganizationAssuranceAlertsExecute(r AlertsAPIGetOrganizationAssuranceAlertsRequest) ([]GetOrganizationAssuranceAlerts200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GetOrganizationAssuranceAlerts200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertsAPIService.GetOrganizationAssuranceAlerts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/assurance/alerts"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterValueToString(r.organizationId, "organizationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "perPage", r.perPage, "")
	}
	if r.startingAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startingAfter", r.startingAfter, "")
	}
	if r.endingBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endingBefore", r.endingBefore, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "")
	}
	if r.networkId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "networkId", r.networkId, "")
	}
	if r.severity != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "severity", r.severity, "")
	}
	if r.types != nil {
		t := *r.types
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "types", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "types", t, "multi")
		}
	}
	if r.tsStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tsStart", r.tsStart, "")
	}
	if r.tsEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tsEnd", r.tsEnd, "")
	}
	if r.category != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "category", r.category, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", r.sortBy, "")
	}
	if r.serials != nil {
		t := *r.serials
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "serials", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "serials", t, "multi")
		}
	}
	if r.deviceTypes != nil {
		t := *r.deviceTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "deviceTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "deviceTypes", t, "multi")
		}
	}
	if r.deviceTags != nil {
		t := *r.deviceTags
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "deviceTags", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "deviceTags", t, "multi")
		}
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "")
	}
	if r.dismissed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dismissed", r.dismissed, "")
	}
	if r.resolved != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resolved", r.resolved, "")
	}
	if r.suppressAlertsForOfflineNodes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suppressAlertsForOfflineNodes", r.suppressAlertsForOfflineNodes, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AlertsAPIGetOrganizationAssuranceAlertsOverviewRequest struct {
	ctx context.Context
	ApiService *AlertsAPIService
	organizationId string
	networkId *string
	severity *string
	types *[]string
	tsStart *time.Time
	tsEnd *time.Time
	serials *[]string
	deviceTypes *[]string
	deviceTags *[]string
	active *bool
	dismissed *bool
	resolved *bool
	suppressAlertsForOfflineNodes *bool
}

// Optional parameter to filter alerts overview by network ids.
func (r AlertsAPIGetOrganizationAssuranceAlertsOverviewRequest) NetworkId(networkId string) AlertsAPIGetOrganizationAssuranceAlertsOverviewRequest {
	r.networkId = &networkId
	return r
}

// Optional parameter to filter alerts overview by severity type.
func (r AlertsAPIGetOrganizationAssuranceAlertsOverviewRequest) Severity(severity string) AlertsAPIGetOrganizationAssuranceAlertsOverviewRequest {
	r.severity = &severity
	return r
}

// Optional parameter to filter by alert type.
func (r AlertsAPIGetOrganizationAssuranceAlertsOverviewRequest) Types(types []string) AlertsAPIGetOrganizationAssuranceAlertsOverviewRequest {
	r.types = &types
	return r
}

// Optional parameter to filter by starting timestamp
func (r AlertsAPIGetOrganizationAssuranceAlertsOverviewRequest) TsStart(tsStart time.Time) AlertsAPIGetOrganizationAssuranceAlertsOverviewRequest {
	r.tsStart = &tsStart
	return r
}

// Optional parameter to filter by end timestamp
func (r AlertsAPIGetOrganizationAssuranceAlertsOverviewRequest) TsEnd(tsEnd time.Time) AlertsAPIGetOrganizationAssuranceAlertsOverviewRequest {
	r.tsEnd = &tsEnd
	return r
}

// Optional parameter to filter by primary device serial
func (r AlertsAPIGetOrganizationAssuranceAlertsOverviewRequest) Serials(serials []string) AlertsAPIGetOrganizationAssuranceAlertsOverviewRequest {
	r.serials = &serials
	return r
}

// Optional parameter to filter by device types
func (r AlertsAPIGetOrganizationAssuranceAlertsOverviewRequest) DeviceTypes(deviceTypes []string) AlertsAPIGetOrganizationAssuranceAlertsOverviewRequest {
	r.deviceTypes = &deviceTypes
	return r
}

// Optional parameter to filter by device tags
func (r AlertsAPIGetOrganizationAssuranceAlertsOverviewRequest) DeviceTags(deviceTags []string) AlertsAPIGetOrganizationAssuranceAlertsOverviewRequest {
	r.deviceTags = &deviceTags
	return r
}

// Optional parameter to filter by active alerts defaults to true
func (r AlertsAPIGetOrganizationAssuranceAlertsOverviewRequest) Active(active bool) AlertsAPIGetOrganizationAssuranceAlertsOverviewRequest {
	r.active = &active
	return r
}

// Optional parameter to filter by dismissed alerts defaults to false
func (r AlertsAPIGetOrganizationAssuranceAlertsOverviewRequest) Dismissed(dismissed bool) AlertsAPIGetOrganizationAssuranceAlertsOverviewRequest {
	r.dismissed = &dismissed
	return r
}

// Optional parameter to filter by resolved alerts defaults to false
func (r AlertsAPIGetOrganizationAssuranceAlertsOverviewRequest) Resolved(resolved bool) AlertsAPIGetOrganizationAssuranceAlertsOverviewRequest {
	r.resolved = &resolved
	return r
}

// When set to true the api will only return connectivity alerts for a given device if that device is in an offline state. This only applies to devices. This is ignored when resolved is true. Example:  If a Switch has a VLan Mismatch and is Unreachable. only the Unreachable alert will be returned. Defaults to false.
func (r AlertsAPIGetOrganizationAssuranceAlertsOverviewRequest) SuppressAlertsForOfflineNodes(suppressAlertsForOfflineNodes bool) AlertsAPIGetOrganizationAssuranceAlertsOverviewRequest {
	r.suppressAlertsForOfflineNodes = &suppressAlertsForOfflineNodes
	return r
}

func (r AlertsAPIGetOrganizationAssuranceAlertsOverviewRequest) Execute() (*GetOrganizationAssuranceAlertsOverview200Response, *http.Response, error) {
	return r.ApiService.GetOrganizationAssuranceAlertsOverviewExecute(r)
}

/*
GetOrganizationAssuranceAlertsOverview Return overview of active health alerts for an organization

Return overview of active health alerts for an organization

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @return AlertsAPIGetOrganizationAssuranceAlertsOverviewRequest
*/
func (a *AlertsAPIService) GetOrganizationAssuranceAlertsOverview(ctx context.Context, organizationId string) AlertsAPIGetOrganizationAssuranceAlertsOverviewRequest {
	return AlertsAPIGetOrganizationAssuranceAlertsOverviewRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
//  @return GetOrganizationAssuranceAlertsOverview200Response
func (a *AlertsAPIService) GetOrganizationAssuranceAlertsOverviewExecute(r AlertsAPIGetOrganizationAssuranceAlertsOverviewRequest) (*GetOrganizationAssuranceAlertsOverview200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetOrganizationAssuranceAlertsOverview200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertsAPIService.GetOrganizationAssuranceAlertsOverview")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/assurance/alerts/overview"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterValueToString(r.organizationId, "organizationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.networkId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "networkId", r.networkId, "")
	}
	if r.severity != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "severity", r.severity, "")
	}
	if r.types != nil {
		t := *r.types
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "types", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "types", t, "multi")
		}
	}
	if r.tsStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tsStart", r.tsStart, "")
	}
	if r.tsEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tsEnd", r.tsEnd, "")
	}
	if r.serials != nil {
		t := *r.serials
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "serials", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "serials", t, "multi")
		}
	}
	if r.deviceTypes != nil {
		t := *r.deviceTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "deviceTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "deviceTypes", t, "multi")
		}
	}
	if r.deviceTags != nil {
		t := *r.deviceTags
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "deviceTags", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "deviceTags", t, "multi")
		}
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "")
	}
	if r.dismissed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dismissed", r.dismissed, "")
	}
	if r.resolved != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resolved", r.resolved, "")
	}
	if r.suppressAlertsForOfflineNodes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suppressAlertsForOfflineNodes", r.suppressAlertsForOfflineNodes, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AlertsAPIGetOrganizationAssuranceAlertsOverviewByNetworkRequest struct {
	ctx context.Context
	ApiService *AlertsAPIService
	organizationId string
	perPage *int32
	startingAfter *string
	endingBefore *string
	sortOrder *string
	networkId *string
	severity *string
	types *[]string
	tsStart *time.Time
	tsEnd *time.Time
	serials *[]string
	deviceTypes *[]string
	deviceTags *[]string
	active *bool
	dismissed *bool
	resolved *bool
	suppressAlertsForOfflineNodes *bool
}

// The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.
func (r AlertsAPIGetOrganizationAssuranceAlertsOverviewByNetworkRequest) PerPage(perPage int32) AlertsAPIGetOrganizationAssuranceAlertsOverviewByNetworkRequest {
	r.perPage = &perPage
	return r
}

// A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
func (r AlertsAPIGetOrganizationAssuranceAlertsOverviewByNetworkRequest) StartingAfter(startingAfter string) AlertsAPIGetOrganizationAssuranceAlertsOverviewByNetworkRequest {
	r.startingAfter = &startingAfter
	return r
}

// A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
func (r AlertsAPIGetOrganizationAssuranceAlertsOverviewByNetworkRequest) EndingBefore(endingBefore string) AlertsAPIGetOrganizationAssuranceAlertsOverviewByNetworkRequest {
	r.endingBefore = &endingBefore
	return r
}

// Sorted order of entries. Order options are &#39;ascending&#39; and &#39;descending&#39;. Default is &#39;ascending&#39;.
func (r AlertsAPIGetOrganizationAssuranceAlertsOverviewByNetworkRequest) SortOrder(sortOrder string) AlertsAPIGetOrganizationAssuranceAlertsOverviewByNetworkRequest {
	r.sortOrder = &sortOrder
	return r
}

// Optional parameter to filter alerts overview by network id.
func (r AlertsAPIGetOrganizationAssuranceAlertsOverviewByNetworkRequest) NetworkId(networkId string) AlertsAPIGetOrganizationAssuranceAlertsOverviewByNetworkRequest {
	r.networkId = &networkId
	return r
}

// Optional parameter to filter alerts overview by severity type.
func (r AlertsAPIGetOrganizationAssuranceAlertsOverviewByNetworkRequest) Severity(severity string) AlertsAPIGetOrganizationAssuranceAlertsOverviewByNetworkRequest {
	r.severity = &severity
	return r
}

// Optional parameter to filter by alert type.
func (r AlertsAPIGetOrganizationAssuranceAlertsOverviewByNetworkRequest) Types(types []string) AlertsAPIGetOrganizationAssuranceAlertsOverviewByNetworkRequest {
	r.types = &types
	return r
}

// Optional parameter to filter by starting timestamp
func (r AlertsAPIGetOrganizationAssuranceAlertsOverviewByNetworkRequest) TsStart(tsStart time.Time) AlertsAPIGetOrganizationAssuranceAlertsOverviewByNetworkRequest {
	r.tsStart = &tsStart
	return r
}

// Optional parameter to filter by end timestamp
func (r AlertsAPIGetOrganizationAssuranceAlertsOverviewByNetworkRequest) TsEnd(tsEnd time.Time) AlertsAPIGetOrganizationAssuranceAlertsOverviewByNetworkRequest {
	r.tsEnd = &tsEnd
	return r
}

// Optional parameter to filter by primary device serial
func (r AlertsAPIGetOrganizationAssuranceAlertsOverviewByNetworkRequest) Serials(serials []string) AlertsAPIGetOrganizationAssuranceAlertsOverviewByNetworkRequest {
	r.serials = &serials
	return r
}

// Optional parameter to filter by device types
func (r AlertsAPIGetOrganizationAssuranceAlertsOverviewByNetworkRequest) DeviceTypes(deviceTypes []string) AlertsAPIGetOrganizationAssuranceAlertsOverviewByNetworkRequest {
	r.deviceTypes = &deviceTypes
	return r
}

// Optional parameter to filter by device tags
func (r AlertsAPIGetOrganizationAssuranceAlertsOverviewByNetworkRequest) DeviceTags(deviceTags []string) AlertsAPIGetOrganizationAssuranceAlertsOverviewByNetworkRequest {
	r.deviceTags = &deviceTags
	return r
}

// Optional parameter to filter by active alerts defaults to true
func (r AlertsAPIGetOrganizationAssuranceAlertsOverviewByNetworkRequest) Active(active bool) AlertsAPIGetOrganizationAssuranceAlertsOverviewByNetworkRequest {
	r.active = &active
	return r
}

// Optional parameter to filter by dismissed alerts defaults to false
func (r AlertsAPIGetOrganizationAssuranceAlertsOverviewByNetworkRequest) Dismissed(dismissed bool) AlertsAPIGetOrganizationAssuranceAlertsOverviewByNetworkRequest {
	r.dismissed = &dismissed
	return r
}

// Optional parameter to filter by resolved alerts defaults to false
func (r AlertsAPIGetOrganizationAssuranceAlertsOverviewByNetworkRequest) Resolved(resolved bool) AlertsAPIGetOrganizationAssuranceAlertsOverviewByNetworkRequest {
	r.resolved = &resolved
	return r
}

// When set to true the api will only return connectivity alerts for a given device if that device is in an offline state. This only applies to devices. This is ignored when resolved is true. Example:  If a Switch has a VLan Mismatch and is Unreachable. only the Unreachable alert will be returned. Defaults to false.
func (r AlertsAPIGetOrganizationAssuranceAlertsOverviewByNetworkRequest) SuppressAlertsForOfflineNodes(suppressAlertsForOfflineNodes bool) AlertsAPIGetOrganizationAssuranceAlertsOverviewByNetworkRequest {
	r.suppressAlertsForOfflineNodes = &suppressAlertsForOfflineNodes
	return r
}

func (r AlertsAPIGetOrganizationAssuranceAlertsOverviewByNetworkRequest) Execute() (*GetOrganizationAssuranceAlertsOverviewByNetwork200Response, *http.Response, error) {
	return r.ApiService.GetOrganizationAssuranceAlertsOverviewByNetworkExecute(r)
}

/*
GetOrganizationAssuranceAlertsOverviewByNetwork Return a Summary of Alerts grouped by network and severity

Return a Summary of Alerts grouped by network and severity

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @return AlertsAPIGetOrganizationAssuranceAlertsOverviewByNetworkRequest
*/
func (a *AlertsAPIService) GetOrganizationAssuranceAlertsOverviewByNetwork(ctx context.Context, organizationId string) AlertsAPIGetOrganizationAssuranceAlertsOverviewByNetworkRequest {
	return AlertsAPIGetOrganizationAssuranceAlertsOverviewByNetworkRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
//  @return GetOrganizationAssuranceAlertsOverviewByNetwork200Response
func (a *AlertsAPIService) GetOrganizationAssuranceAlertsOverviewByNetworkExecute(r AlertsAPIGetOrganizationAssuranceAlertsOverviewByNetworkRequest) (*GetOrganizationAssuranceAlertsOverviewByNetwork200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetOrganizationAssuranceAlertsOverviewByNetwork200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertsAPIService.GetOrganizationAssuranceAlertsOverviewByNetwork")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/assurance/alerts/overview/byNetwork"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterValueToString(r.organizationId, "organizationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "perPage", r.perPage, "")
	}
	if r.startingAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startingAfter", r.startingAfter, "")
	}
	if r.endingBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endingBefore", r.endingBefore, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "")
	}
	if r.networkId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "networkId", r.networkId, "")
	}
	if r.severity != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "severity", r.severity, "")
	}
	if r.types != nil {
		t := *r.types
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "types", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "types", t, "multi")
		}
	}
	if r.tsStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tsStart", r.tsStart, "")
	}
	if r.tsEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tsEnd", r.tsEnd, "")
	}
	if r.serials != nil {
		t := *r.serials
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "serials", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "serials", t, "multi")
		}
	}
	if r.deviceTypes != nil {
		t := *r.deviceTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "deviceTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "deviceTypes", t, "multi")
		}
	}
	if r.deviceTags != nil {
		t := *r.deviceTags
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "deviceTags", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "deviceTags", t, "multi")
		}
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "")
	}
	if r.dismissed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dismissed", r.dismissed, "")
	}
	if r.resolved != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resolved", r.resolved, "")
	}
	if r.suppressAlertsForOfflineNodes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suppressAlertsForOfflineNodes", r.suppressAlertsForOfflineNodes, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AlertsAPIGetOrganizationAssuranceAlertsOverviewByTypeRequest struct {
	ctx context.Context
	ApiService *AlertsAPIService
	organizationId string
	perPage *int32
	startingAfter *string
	endingBefore *string
	sortOrder *string
	networkId *string
	severity *string
	types *[]string
	tsStart *time.Time
	tsEnd *time.Time
	sortBy *string
	serials *[]string
	deviceTypes *[]string
	deviceTags *[]string
	active *bool
	dismissed *bool
	resolved *bool
	suppressAlertsForOfflineNodes *bool
}

// The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000.
func (r AlertsAPIGetOrganizationAssuranceAlertsOverviewByTypeRequest) PerPage(perPage int32) AlertsAPIGetOrganizationAssuranceAlertsOverviewByTypeRequest {
	r.perPage = &perPage
	return r
}

// A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
func (r AlertsAPIGetOrganizationAssuranceAlertsOverviewByTypeRequest) StartingAfter(startingAfter string) AlertsAPIGetOrganizationAssuranceAlertsOverviewByTypeRequest {
	r.startingAfter = &startingAfter
	return r
}

// A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it.
func (r AlertsAPIGetOrganizationAssuranceAlertsOverviewByTypeRequest) EndingBefore(endingBefore string) AlertsAPIGetOrganizationAssuranceAlertsOverviewByTypeRequest {
	r.endingBefore = &endingBefore
	return r
}

// Sorted order of entries. Order options are &#39;ascending&#39; and &#39;descending&#39;. Default is &#39;ascending&#39;.
func (r AlertsAPIGetOrganizationAssuranceAlertsOverviewByTypeRequest) SortOrder(sortOrder string) AlertsAPIGetOrganizationAssuranceAlertsOverviewByTypeRequest {
	r.sortOrder = &sortOrder
	return r
}

// Optional parameter to filter alerts overview by network ids.
func (r AlertsAPIGetOrganizationAssuranceAlertsOverviewByTypeRequest) NetworkId(networkId string) AlertsAPIGetOrganizationAssuranceAlertsOverviewByTypeRequest {
	r.networkId = &networkId
	return r
}

// Optional parameter to filter alerts overview by severity type.
func (r AlertsAPIGetOrganizationAssuranceAlertsOverviewByTypeRequest) Severity(severity string) AlertsAPIGetOrganizationAssuranceAlertsOverviewByTypeRequest {
	r.severity = &severity
	return r
}

// Optional parameter to filter by alert type.
func (r AlertsAPIGetOrganizationAssuranceAlertsOverviewByTypeRequest) Types(types []string) AlertsAPIGetOrganizationAssuranceAlertsOverviewByTypeRequest {
	r.types = &types
	return r
}

// Optional parameter to filter by starting timestamp
func (r AlertsAPIGetOrganizationAssuranceAlertsOverviewByTypeRequest) TsStart(tsStart time.Time) AlertsAPIGetOrganizationAssuranceAlertsOverviewByTypeRequest {
	r.tsStart = &tsStart
	return r
}

// Optional parameter to filter by end timestamp
func (r AlertsAPIGetOrganizationAssuranceAlertsOverviewByTypeRequest) TsEnd(tsEnd time.Time) AlertsAPIGetOrganizationAssuranceAlertsOverviewByTypeRequest {
	r.tsEnd = &tsEnd
	return r
}

// Optional parameter to set column to sort by.
func (r AlertsAPIGetOrganizationAssuranceAlertsOverviewByTypeRequest) SortBy(sortBy string) AlertsAPIGetOrganizationAssuranceAlertsOverviewByTypeRequest {
	r.sortBy = &sortBy
	return r
}

// Optional parameter to filter by primary device serial
func (r AlertsAPIGetOrganizationAssuranceAlertsOverviewByTypeRequest) Serials(serials []string) AlertsAPIGetOrganizationAssuranceAlertsOverviewByTypeRequest {
	r.serials = &serials
	return r
}

// Optional parameter to filter by device types
func (r AlertsAPIGetOrganizationAssuranceAlertsOverviewByTypeRequest) DeviceTypes(deviceTypes []string) AlertsAPIGetOrganizationAssuranceAlertsOverviewByTypeRequest {
	r.deviceTypes = &deviceTypes
	return r
}

// Optional parameter to filter by device tags
func (r AlertsAPIGetOrganizationAssuranceAlertsOverviewByTypeRequest) DeviceTags(deviceTags []string) AlertsAPIGetOrganizationAssuranceAlertsOverviewByTypeRequest {
	r.deviceTags = &deviceTags
	return r
}

// Optional parameter to filter by active alerts defaults to true
func (r AlertsAPIGetOrganizationAssuranceAlertsOverviewByTypeRequest) Active(active bool) AlertsAPIGetOrganizationAssuranceAlertsOverviewByTypeRequest {
	r.active = &active
	return r
}

// Optional parameter to filter by dismissed alerts defaults to false
func (r AlertsAPIGetOrganizationAssuranceAlertsOverviewByTypeRequest) Dismissed(dismissed bool) AlertsAPIGetOrganizationAssuranceAlertsOverviewByTypeRequest {
	r.dismissed = &dismissed
	return r
}

// Optional parameter to filter by resolved alerts defaults to false
func (r AlertsAPIGetOrganizationAssuranceAlertsOverviewByTypeRequest) Resolved(resolved bool) AlertsAPIGetOrganizationAssuranceAlertsOverviewByTypeRequest {
	r.resolved = &resolved
	return r
}

// When set to true the api will only return connectivity alerts for a given device if that device is in an offline state. This only applies to devices. This is ignored when resolved is true. Example:  If a Switch has a VLan Mismatch and is Unreachable. only the Unreachable alert will be returned. Defaults to false.
func (r AlertsAPIGetOrganizationAssuranceAlertsOverviewByTypeRequest) SuppressAlertsForOfflineNodes(suppressAlertsForOfflineNodes bool) AlertsAPIGetOrganizationAssuranceAlertsOverviewByTypeRequest {
	r.suppressAlertsForOfflineNodes = &suppressAlertsForOfflineNodes
	return r
}

func (r AlertsAPIGetOrganizationAssuranceAlertsOverviewByTypeRequest) Execute() (*GetOrganizationAssuranceAlertsOverviewByType200Response, *http.Response, error) {
	return r.ApiService.GetOrganizationAssuranceAlertsOverviewByTypeExecute(r)
}

/*
GetOrganizationAssuranceAlertsOverviewByType Return a Summary of Alerts grouped by type and severity

Return a Summary of Alerts grouped by type and severity

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @return AlertsAPIGetOrganizationAssuranceAlertsOverviewByTypeRequest
*/
func (a *AlertsAPIService) GetOrganizationAssuranceAlertsOverviewByType(ctx context.Context, organizationId string) AlertsAPIGetOrganizationAssuranceAlertsOverviewByTypeRequest {
	return AlertsAPIGetOrganizationAssuranceAlertsOverviewByTypeRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
//  @return GetOrganizationAssuranceAlertsOverviewByType200Response
func (a *AlertsAPIService) GetOrganizationAssuranceAlertsOverviewByTypeExecute(r AlertsAPIGetOrganizationAssuranceAlertsOverviewByTypeRequest) (*GetOrganizationAssuranceAlertsOverviewByType200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetOrganizationAssuranceAlertsOverviewByType200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertsAPIService.GetOrganizationAssuranceAlertsOverviewByType")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/assurance/alerts/overview/byType"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterValueToString(r.organizationId, "organizationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "perPage", r.perPage, "")
	}
	if r.startingAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startingAfter", r.startingAfter, "")
	}
	if r.endingBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endingBefore", r.endingBefore, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "")
	}
	if r.networkId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "networkId", r.networkId, "")
	}
	if r.severity != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "severity", r.severity, "")
	}
	if r.types != nil {
		t := *r.types
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "types", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "types", t, "multi")
		}
	}
	if r.tsStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tsStart", r.tsStart, "")
	}
	if r.tsEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tsEnd", r.tsEnd, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", r.sortBy, "")
	}
	if r.serials != nil {
		t := *r.serials
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "serials", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "serials", t, "multi")
		}
	}
	if r.deviceTypes != nil {
		t := *r.deviceTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "deviceTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "deviceTypes", t, "multi")
		}
	}
	if r.deviceTags != nil {
		t := *r.deviceTags
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "deviceTags", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "deviceTags", t, "multi")
		}
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "")
	}
	if r.dismissed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dismissed", r.dismissed, "")
	}
	if r.resolved != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resolved", r.resolved, "")
	}
	if r.suppressAlertsForOfflineNodes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "suppressAlertsForOfflineNodes", r.suppressAlertsForOfflineNodes, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AlertsAPIGetOrganizationAssuranceAlertsOverviewHistoricalRequest struct {
	ctx context.Context
	ApiService *AlertsAPIService
	organizationId string
	segmentDuration *int32
	tsStart *time.Time
	networkId *string
	severity *string
	types *[]string
	tsEnd *time.Time
	serials *[]string
	deviceTypes *[]string
}

// Amount of time in seconds for each segment in the returned dataset
func (r AlertsAPIGetOrganizationAssuranceAlertsOverviewHistoricalRequest) SegmentDuration(segmentDuration int32) AlertsAPIGetOrganizationAssuranceAlertsOverviewHistoricalRequest {
	r.segmentDuration = &segmentDuration
	return r
}

// Parameter to define starting timestamp of historical totals
func (r AlertsAPIGetOrganizationAssuranceAlertsOverviewHistoricalRequest) TsStart(tsStart time.Time) AlertsAPIGetOrganizationAssuranceAlertsOverviewHistoricalRequest {
	r.tsStart = &tsStart
	return r
}

// Optional parameter to filter alerts overview by network ids.
func (r AlertsAPIGetOrganizationAssuranceAlertsOverviewHistoricalRequest) NetworkId(networkId string) AlertsAPIGetOrganizationAssuranceAlertsOverviewHistoricalRequest {
	r.networkId = &networkId
	return r
}

// Optional parameter to filter alerts overview by severity type.
func (r AlertsAPIGetOrganizationAssuranceAlertsOverviewHistoricalRequest) Severity(severity string) AlertsAPIGetOrganizationAssuranceAlertsOverviewHistoricalRequest {
	r.severity = &severity
	return r
}

// Optional parameter to filter by alert type.
func (r AlertsAPIGetOrganizationAssuranceAlertsOverviewHistoricalRequest) Types(types []string) AlertsAPIGetOrganizationAssuranceAlertsOverviewHistoricalRequest {
	r.types = &types
	return r
}

// Optional parameter to filter by end timestamp defaults to the current time
func (r AlertsAPIGetOrganizationAssuranceAlertsOverviewHistoricalRequest) TsEnd(tsEnd time.Time) AlertsAPIGetOrganizationAssuranceAlertsOverviewHistoricalRequest {
	r.tsEnd = &tsEnd
	return r
}

// Optional parameter to filter by primary device serial
func (r AlertsAPIGetOrganizationAssuranceAlertsOverviewHistoricalRequest) Serials(serials []string) AlertsAPIGetOrganizationAssuranceAlertsOverviewHistoricalRequest {
	r.serials = &serials
	return r
}

// Optional parameter to filter by device types
func (r AlertsAPIGetOrganizationAssuranceAlertsOverviewHistoricalRequest) DeviceTypes(deviceTypes []string) AlertsAPIGetOrganizationAssuranceAlertsOverviewHistoricalRequest {
	r.deviceTypes = &deviceTypes
	return r
}

func (r AlertsAPIGetOrganizationAssuranceAlertsOverviewHistoricalRequest) Execute() (*GetOrganizationAssuranceAlertsOverviewHistorical200Response, *http.Response, error) {
	return r.ApiService.GetOrganizationAssuranceAlertsOverviewHistoricalExecute(r)
}

/*
GetOrganizationAssuranceAlertsOverviewHistorical Returns historical health alert overviews

Returns historical health alert overviews

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @return AlertsAPIGetOrganizationAssuranceAlertsOverviewHistoricalRequest
*/
func (a *AlertsAPIService) GetOrganizationAssuranceAlertsOverviewHistorical(ctx context.Context, organizationId string) AlertsAPIGetOrganizationAssuranceAlertsOverviewHistoricalRequest {
	return AlertsAPIGetOrganizationAssuranceAlertsOverviewHistoricalRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
//  @return GetOrganizationAssuranceAlertsOverviewHistorical200Response
func (a *AlertsAPIService) GetOrganizationAssuranceAlertsOverviewHistoricalExecute(r AlertsAPIGetOrganizationAssuranceAlertsOverviewHistoricalRequest) (*GetOrganizationAssuranceAlertsOverviewHistorical200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetOrganizationAssuranceAlertsOverviewHistorical200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertsAPIService.GetOrganizationAssuranceAlertsOverviewHistorical")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/assurance/alerts/overview/historical"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterValueToString(r.organizationId, "organizationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.segmentDuration == nil {
		return localVarReturnValue, nil, reportError("segmentDuration is required and must be specified")
	}
	if r.tsStart == nil {
		return localVarReturnValue, nil, reportError("tsStart is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "segmentDuration", r.segmentDuration, "")
	if r.networkId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "networkId", r.networkId, "")
	}
	if r.severity != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "severity", r.severity, "")
	}
	if r.types != nil {
		t := *r.types
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "types", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "types", t, "multi")
		}
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "tsStart", r.tsStart, "")
	if r.tsEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tsEnd", r.tsEnd, "")
	}
	if r.serials != nil {
		t := *r.serials
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "serials", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "serials", t, "multi")
		}
	}
	if r.deviceTypes != nil {
		t := *r.deviceTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "deviceTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "deviceTypes", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AlertsAPIRestoreOrganizationAssuranceAlertsRequest struct {
	ctx context.Context
	ApiService *AlertsAPIService
	organizationId string
	restoreOrganizationAssuranceAlertsRequest *RestoreOrganizationAssuranceAlertsRequest
}

func (r AlertsAPIRestoreOrganizationAssuranceAlertsRequest) RestoreOrganizationAssuranceAlertsRequest(restoreOrganizationAssuranceAlertsRequest RestoreOrganizationAssuranceAlertsRequest) AlertsAPIRestoreOrganizationAssuranceAlertsRequest {
	r.restoreOrganizationAssuranceAlertsRequest = &restoreOrganizationAssuranceAlertsRequest
	return r
}

func (r AlertsAPIRestoreOrganizationAssuranceAlertsRequest) Execute() (*http.Response, error) {
	return r.ApiService.RestoreOrganizationAssuranceAlertsExecute(r)
}

/*
RestoreOrganizationAssuranceAlerts Restore health alerts from dismissed

Restore health alerts from dismissed

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @return AlertsAPIRestoreOrganizationAssuranceAlertsRequest
*/
func (a *AlertsAPIService) RestoreOrganizationAssuranceAlerts(ctx context.Context, organizationId string) AlertsAPIRestoreOrganizationAssuranceAlertsRequest {
	return AlertsAPIRestoreOrganizationAssuranceAlertsRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
func (a *AlertsAPIService) RestoreOrganizationAssuranceAlertsExecute(r AlertsAPIRestoreOrganizationAssuranceAlertsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertsAPIService.RestoreOrganizationAssuranceAlerts")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/assurance/alerts/restore"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterValueToString(r.organizationId, "organizationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.restoreOrganizationAssuranceAlertsRequest == nil {
		return nil, reportError("restoreOrganizationAssuranceAlertsRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.restoreOrganizationAssuranceAlertsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type AlertsAPIUpdateNetworkAlertsSettingsRequest struct {
	ctx context.Context
	ApiService *AlertsAPIService
	networkId string
	updateNetworkAlertsSettingsRequest *UpdateNetworkAlertsSettingsRequest
}

func (r AlertsAPIUpdateNetworkAlertsSettingsRequest) UpdateNetworkAlertsSettingsRequest(updateNetworkAlertsSettingsRequest UpdateNetworkAlertsSettingsRequest) AlertsAPIUpdateNetworkAlertsSettingsRequest {
	r.updateNetworkAlertsSettingsRequest = &updateNetworkAlertsSettingsRequest
	return r
}

func (r AlertsAPIUpdateNetworkAlertsSettingsRequest) Execute() (*GetNetworkAlertsSettings200Response, *http.Response, error) {
	return r.ApiService.UpdateNetworkAlertsSettingsExecute(r)
}

/*
UpdateNetworkAlertsSettings Update the alert configuration for this network

Update the alert configuration for this network

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param networkId Network ID
 @return AlertsAPIUpdateNetworkAlertsSettingsRequest
*/
func (a *AlertsAPIService) UpdateNetworkAlertsSettings(ctx context.Context, networkId string) AlertsAPIUpdateNetworkAlertsSettingsRequest {
	return AlertsAPIUpdateNetworkAlertsSettingsRequest{
		ApiService: a,
		ctx: ctx,
		networkId: networkId,
	}
}

// Execute executes the request
//  @return GetNetworkAlertsSettings200Response
func (a *AlertsAPIService) UpdateNetworkAlertsSettingsExecute(r AlertsAPIUpdateNetworkAlertsSettingsRequest) (*GetNetworkAlertsSettings200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetNetworkAlertsSettings200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertsAPIService.UpdateNetworkAlertsSettings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networks/{networkId}/alerts/settings"
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", url.PathEscape(parameterValueToString(r.networkId, "networkId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateNetworkAlertsSettingsRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AlertsAPIUpdateNetworkSensorAlertsProfileRequest struct {
	ctx context.Context
	ApiService *AlertsAPIService
	networkId string
	id string
	updateNetworkSensorAlertsProfileRequest *UpdateNetworkSensorAlertsProfileRequest
}

func (r AlertsAPIUpdateNetworkSensorAlertsProfileRequest) UpdateNetworkSensorAlertsProfileRequest(updateNetworkSensorAlertsProfileRequest UpdateNetworkSensorAlertsProfileRequest) AlertsAPIUpdateNetworkSensorAlertsProfileRequest {
	r.updateNetworkSensorAlertsProfileRequest = &updateNetworkSensorAlertsProfileRequest
	return r
}

func (r AlertsAPIUpdateNetworkSensorAlertsProfileRequest) Execute() (*GetNetworkSensorAlertsProfiles200ResponseInner, *http.Response, error) {
	return r.ApiService.UpdateNetworkSensorAlertsProfileExecute(r)
}

/*
UpdateNetworkSensorAlertsProfile Updates a sensor alert profile for a network.

Updates a sensor alert profile for a network.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param networkId Network ID
 @param id ID
 @return AlertsAPIUpdateNetworkSensorAlertsProfileRequest
*/
func (a *AlertsAPIService) UpdateNetworkSensorAlertsProfile(ctx context.Context, networkId string, id string) AlertsAPIUpdateNetworkSensorAlertsProfileRequest {
	return AlertsAPIUpdateNetworkSensorAlertsProfileRequest{
		ApiService: a,
		ctx: ctx,
		networkId: networkId,
		id: id,
	}
}

// Execute executes the request
//  @return GetNetworkSensorAlertsProfiles200ResponseInner
func (a *AlertsAPIService) UpdateNetworkSensorAlertsProfileExecute(r AlertsAPIUpdateNetworkSensorAlertsProfileRequest) (*GetNetworkSensorAlertsProfiles200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetNetworkSensorAlertsProfiles200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertsAPIService.UpdateNetworkSensorAlertsProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/networks/{networkId}/sensor/alerts/profiles/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"networkId"+"}", url.PathEscape(parameterValueToString(r.networkId, "networkId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateNetworkSensorAlertsProfileRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type AlertsAPIUpdateOrganizationAlertsProfileRequest struct {
	ctx context.Context
	ApiService *AlertsAPIService
	organizationId string
	alertConfigId string
	updateOrganizationAlertsProfileRequest *UpdateOrganizationAlertsProfileRequest
}

func (r AlertsAPIUpdateOrganizationAlertsProfileRequest) UpdateOrganizationAlertsProfileRequest(updateOrganizationAlertsProfileRequest UpdateOrganizationAlertsProfileRequest) AlertsAPIUpdateOrganizationAlertsProfileRequest {
	r.updateOrganizationAlertsProfileRequest = &updateOrganizationAlertsProfileRequest
	return r
}

func (r AlertsAPIUpdateOrganizationAlertsProfileRequest) Execute() (*GetOrganizationAlertsProfiles200ResponseInner, *http.Response, error) {
	return r.ApiService.UpdateOrganizationAlertsProfileExecute(r)
}

/*
UpdateOrganizationAlertsProfile Update an organization-wide alert config

Update an organization-wide alert config

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId Organization ID
 @param alertConfigId Alert config ID
 @return AlertsAPIUpdateOrganizationAlertsProfileRequest
*/
func (a *AlertsAPIService) UpdateOrganizationAlertsProfile(ctx context.Context, organizationId string, alertConfigId string) AlertsAPIUpdateOrganizationAlertsProfileRequest {
	return AlertsAPIUpdateOrganizationAlertsProfileRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
		alertConfigId: alertConfigId,
	}
}

// Execute executes the request
//  @return GetOrganizationAlertsProfiles200ResponseInner
func (a *AlertsAPIService) UpdateOrganizationAlertsProfileExecute(r AlertsAPIUpdateOrganizationAlertsProfileRequest) (*GetOrganizationAlertsProfiles200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetOrganizationAlertsProfiles200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertsAPIService.UpdateOrganizationAlertsProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/organizations/{organizationId}/alerts/profiles/{alertConfigId}"
	localVarPath = strings.Replace(localVarPath, "{"+"organizationId"+"}", url.PathEscape(parameterValueToString(r.organizationId, "organizationId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"alertConfigId"+"}", url.PathEscape(parameterValueToString(r.alertConfigId, "alertConfigId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateOrganizationAlertsProfileRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["meraki_api_key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-Cisco-Meraki-API-Key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
